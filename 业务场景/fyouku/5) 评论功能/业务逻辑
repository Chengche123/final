1 获取评论列表接口:
    1)用episodesId做通配请求
    2)在comment表中查两次,第一次查总的评论数,第二次根据offset和limit查具体评论(根据添加时间降序),两次查询都只查status正常的行
    3)得到总的评论数,每条评论的id,内容,添加时间,评论用户id,盖章(1=热评;2=公告),点赞数,评论视频id
    4)根据评论用户id,调用获取用户信息的接口
    5)返回总的评论数,每条评论的id,内容,添加时间,评论用户id,盖章(1=热评;2=公告),点赞数,评论视频id,评论用户名,用户头像和用户注册时间

2 保存评论接口:
    1)用content,uid,episodesId,videoId做通配请求
    2)将评论保存在comment表中,将video表中相应视频的总评论数加1,将video_episodes表中相应剧集的评论数加1
    3)只返回状态信息,不返回业务字段

3 Redis改造根据用户ID获取用户信息models:
    1)定义redisKey为user:id:加上用户id,用exists判断缓存是否存在
    2)若缓存miss,调用原来的models方法获取到一个user对象,用hmset保存到redis中,设置过期时间为1天
    3)若缓存命中,用hgetall获取在哈希表中的所有字段和值,反序列化成user对象
    4)返回user对象

4 Goroutine改造获取评论列表接口:
    1)其他业务逻辑保持不变,仅在获取到评论用户的id后,从原来的串行调用获取用户信息的models方法,改为并发调用
    2)因为要限制并发数,任务编排用channel






