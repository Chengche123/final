1 (框架)CPU概要文件:
    一: 在默认情况下，Go语言的运行时系统会以100 Hz的的频率对CPU使用情况进行取样。
    二: 通常放在main函数中:
        f, err := os.Create("cpu.prof")
        if err != nil {
            log.Panic(err)
        }
        defer f.Close()
        err = pprof.StartCPUProfile(f)
        if err != nil {
            log.Panic(err)
        }
        defer pprof.StopCPUProfile()

2 (框架)内存概要文件:
    一: 分析器将会在每分配指定的字节数量后对内存使用情况进行取样
        即使我们不给runtime.MemProfileRate变量赋值，内存使用情况的取样操作也会照样进行
        runtime.MemProfileRate变量的默认值是512 * 1024，即512K个字节。
    二: 在默认情况下，内存使用情况的取样数据只会被保存在运行时内存中，而保存到文件的操作只能由我们自己来完成:
        memf, err := os.Create("mem.prof")
        if err != nil {
            panic(err)
        }
        err = pprof.WriteHeapProfile(memf)
        if err != nil {
            panic(err)
        }
        memf.Close()

3 (框架)程序阻塞概要文件:
    一: 在默认情况下是关闭的
        开启方法: runtime.SetBlockProfileRate(1) 每发生一次Goroutine阻塞事件，分析器就会取样一次
    二: 我们在程序结束之前可以将被保存在运行时内存中的Goroutine阻塞事件记录存放到指定的文件中
        blockFile, err := os.Create("block.prof")
        if err != nil {
            panic(err)
        }
        err = pprof.Lookup("block").WriteTo(blockFile, 0)
        if err != nil {
            panic(err)
        }
        blockFile.Close()

4 (框架-go test):
    go test -v -run TestReverse -cpuprofile cpu.prof -blockprofile block.prof -memprofile mem.prof