1 runtime.GOMAXPROCS 函数:
    用户程序可以在运行期间，设置常规运行时系统中的P的最大数量
    这样做会引起“Stop the world”，所以我强烈建议应用程序尽量早地，并且更好的方式是设置环境变量GOMAXPROCS 。
    Go运行时系统中的P最大数量范围总会是1~256。

2 (框架)runtime.Goexit 函数:
    runtime.Goexit 函数在终止当前goroutine之前，会先执行该goroutine中所有还未执行的defer 语句。

3 runtime.Gosched 函数:
    runtime.Gosched 函数的作用是暂停当前goroutine的运行

4 (框架)runtime.NumGoroutine 函数:
    返回当前Go运行时系统中处于非Gdead 状态的用户G的数量

5 runtime.LockOSThread 函数和runtime.UnlockOSThread 函数:
    前者的调用会使当前goroutine与当前M锁定在一起，而对后者的调用则会解除这样的锁定

6 runtime/debug.SetMaxStack 函数:
    runtime/debug.SetMaxStack 函数的功能是约束单个goroutine所能申请栈空间的最大尺寸
    主goroutine会对此数值进行默认设置。250 MB和1 GB分别是在32位和64位的计算机系统下的默认值。

7 runtime/debug.SetMaxThreads 函数:
    对Go运行时系统所使用的内核线程的数量（也可以认为是M的数量）进行设置
    在引导程序中，该数量被设置成了10 000。这对于操作系统和Go程序来说，都已经是一个足够大的值了

8 (框架)与垃圾回收有关的一些函数:
    runtime/debug.SetGCPercent 、runtime.GC 和runtime/debug.FreeOSMemory
    前者用于设定触发自动GC的条件，而后两者用于发起手动GC
    自动GC在默认情况下是并发运行的，而手动GC则总是串行运行的。这也意味着，在后两个函数的执行期间，调度是停止的
    runtime/ debug.FreeOSMemory 函数比runtime.GC 函数多做了一件事，那就是在GC之后还要清扫一次堆内存。
    
    

