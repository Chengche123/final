1 两阶段锁:
    一: 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，
        而是要等到事务结束时才释放。这个就是两阶段锁协议。
    二: 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

2 死锁:
    一: 当出现死锁以后，有两种策略：
        1)通过参数innodb_lock_wait_timeout来设置等待超时时间
        2)将参数innodb_deadlock_detect设置为on,发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行

3 由热点行更新导致的性能问题:
    一: 所有事务都要更新同一行,每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁;
        这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的
        CPU 利用率很高，但是每秒却执行不了几个事务。
    二: 解决办法:
        1)临时把死锁检测关掉
        2)控制并发度: 对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。
        3)从设计上优化: 将一行改成逻辑上的多行来减少锁冲突.以影院账户为例，可以放在多条记录上,账户总额等于这些记录的值的总和。

