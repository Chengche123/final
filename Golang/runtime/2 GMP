1 goroutine和kst的区别:
    一: 内存占用: 创建一个g的栈内存消耗只有2kb,并且支持扩容,kst的栈内存为1-8MB,并且无法改变,有溢出风险
    二: 创建/销毁: 线程的创建和销毁会陷入内核,开销非常大,而g的创建和销毁在用户态,开销很小
    三: 调度切换: 除了陷入内核外,kst上下文切换时保存的的寄存器(PC,IR,PSW,堆栈指针和各种通用寄存器和特殊寄存器)较多,
        为了公平性还需要进行复杂的计算,开销比较大,而g的切换在用户态并且需要保存的上下文信息极少,开销小得多
    四: 复杂性: //TODO

.1 简介:
    一:
        M ：machine的缩写。一个M代表一个内核线程，或称“工作线程”。
        P ：processor的缩写。一个P代表执行一个Go代码片段所必需的资源（或称“上下文环境”）。
            每个P都会包含一个可运行的G的队列（runq）
        G ：goroutine的缩写。一个G代表一个Go代码片段。前者是对后者的一种封装。
    二: M与KST之间总是一对一的关系 一个M在其生命周期内，会且仅会与一个KST产生关联
        M与P之间也总是一对一的 M与P之间的关联是易变的
        P与G之间则是一对多的关系 P与G之间的关联是易变的

.2 协程优点：
    一:避免了内核态和用户态的切换导致的成本,包括内存的分配与释放，都是在用户态维护着一块大的内存池， 
       不直接调用系统的malloc函数（除非内存池需要改变）
    二:更小的栈空间允许创建大量的实例(动态栈,*goroutine：*2KB ，线程：2MB)

.3 协程调度:
    go的线程模型是M：N的。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，
    包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变）。 
    另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，
    以上种种保证了go调度方面的性能。






