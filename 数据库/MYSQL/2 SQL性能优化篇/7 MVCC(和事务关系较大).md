1 理解:
    一:
        而**每行数据也都是有多个版本**的。**每次事务更新数据的时候，都会生成一个新的数据版本**，**并且在这个数据版本中它也会记录这个事务的ID**，记为 row trx_id。同时，**旧的数据版本要保留**，并且在新的数据版本中，能够有信息可以直接拿到它。
    二:
        按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。
        因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，**如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认**，我必须要找到它的上一个版本”。
        当然，**如果“上一个版本”也不可见，那就得继续往前找**。还有，如果是这个事务自己更新的数据，它自己还是要认的。

2 举例:
    一: 配图为三个事务
    二: 表:
            mysql> CREATE TABLE `t` (
            `id` int(11) NOT NULL,
            `k` int(11) DEFAULT NULL,
            PRIMARY KEY (`id`)
            ) ENGINE=InnoDB;
            insert into t(id, k) values(1,1),(2,2);
    三: 事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1
    四: 如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。
        但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。

2 关键点:
    (框架)一: 在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个**快照是基于整库的。**


