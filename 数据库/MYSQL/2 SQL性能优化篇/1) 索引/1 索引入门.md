1 索引的常见模型  
    一: **哈希表这种结构适用于只有等值查询的场景**，比如 Memcached 及其他一些 NoSQL 引擎。  
    二: 有序数组在等值查询和范围查询场景中的性能就都非常优秀。  
        有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。  
    三: N叉树  
  
2 InnoDB 的索引模型:  
    一: 表根据主键顺序以索引的形式存放  
    二: **主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。**
        **非主键索引的叶子节点内容是主键的值。**在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。  
    三: (回表)  
        1)如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；  
        2)如果语句是 select * from T where k=5，即普通索引查询方式，  
          则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。  
  
3 索引维护:  
    一: 页分裂操作会影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。  
    二: 页合并: 当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。  
  
3 案例: 自增主键  
    一: 插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。  
    二: 从性能考虐:  
        **1)每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。**  
        2)用有业务逻辑的字段做主键，往往不容易保证有序插入，这样写数据成本相对较高。  
    三: 从存储空间考虑:  
        1)**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**
    四: 是否选用自增主键:  
        1) 从性能和存储空间方面考量，自增主键往往是更合理的选择。  
        2) 典型的KV场景(只有一个索引)适合用业务字段直接做主键  
  
4 索引优化:  
    一: **覆盖索引** 例: ID为主键,对k建立索引  
        1)执行select ID from T where k between 3 and 5语句,ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表  
          **在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，不再需要回表, 我们称为覆盖索引**  
        2)由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。  
        3)在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？  
          如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。  
          **它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。**  
    二: **最左前缀原则**
        1)不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。  
          **这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。**  
        2)**当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了**  
        3)如果既有联合查询，又有基于 a、b各自的查询呢？需要同时维护 (a,b)、(b) 这两个索引。  
          这时候要考虑的就是空间了,name字段是比age字段大的,那就创建一个（name,age) 的联合索引和一个 (age) 的单字段索引  
  
5 联合索引下的联合排序:  
    一: 前提: a,b为联合主键  
    二:  
        表记录  
        –a--|–b--|–c--|–d--  
        1 2 3 d  
        1 3 2 d  
        1 4 3 d  
        2 1 3 d  
        2 2 2 d  
        2 3 4 d  
        **主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序。**  
    三:   
        索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键  
        –c--|–a--|–主键部分b-- （注意，这里不是 ab，而是只有 b）  
        2 1 3  
        2 2 2  
        3 1 2  
        3 1 4  
        3 2 1  
        4 2 3  
        **这个跟索引 c 的数据是一模一样的**。  
    四:  
        **索引 cb 的组织是先按 c 排序，在按 b 排序，同时记录主键**  
        –c--|–b--|–主键部分a-- （同上）  
        2 2 2  
        2 3 1  
        3 1 2  
        3 2 1  
        3 4 1  
        4 3 2  
  
  
6 **索引重建**:  
    一: 索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，  
        把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。  
  
.1 索引下推:  
    一: 具体场景: 联合索引（name, age）  
        mysql> select * from tuser where name like '张 %' and age=10 and ismale=1;  
    二: 在 MySQL 5.6 之前，只能一个个回表。到主键索引上找出数据行，再对比字段值。  
    三: 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，  
        (对联合索引中的其他字段先做过滤)对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。  
  
  
  
      
  
