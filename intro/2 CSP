1 博客地址:https://www.jianshu.com/p/36e246c6153d
1) channel:CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。
   在实现原理上其实是一个阻塞的消息队列。
2) 解耦:一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，
   两个实体之间是匿名的，这个就实现实体中间的解耦
3) Goroutine:Goroutine 是实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程
4) coroutine:go底层选择使用coroutine的出发点是因为，它具有以下特点：
    一:用户空间 避免了内核态和用户态的切换导致的成本,包括内存的分配与释放，都是在用户态维护着一块大的内存池， 
    不直接调用系统的malloc函数（除非内存池需要改变）
    二:可以由语言和框架层进行调度
    三:更小的栈空间允许创建大量的实例
5) Goroutine 调度器:
    golang 通过为goroutine提供语言层面的调度器，来实现了高效率的M:N线程对应关系:用户线程和内核线程是多对多的对应关系
6) 优势:单从线程调度讲，go比起其他语言的优势在哪里了？
    go的线程模型是M：N的。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，
    包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变）。 
    另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，
    以上种种保证了go调度方面的性能。