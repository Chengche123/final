1   一: 代码:
            now := time.Now()
            for i := 1; i <= 100; i++ {
                for j := 1; j <= 1000; j++ {
                    for k := 1; k <= 10000; k++ {

                    }
                }
            }
            fmt.Println(time.Now().Sub(now))

            now = time.Now()
            for i := 1; i <= 10000; i++ {
                for j := 1; j <= 1000; j++ {
                    for k := 1; k <= 100; k++ {

                    }
                }
            }
            fmt.Println(time.Now().Sub(now))
    二: 输出
            E:\final\Go\Go Final>go run .
            287.2123ms
            339.0937ms

            E:\final\Go\Go Final>go run .
            285.2441ms
            337.1729ms

            E:\final\Go\Go Final>go run .
            270.3074ms
            328.092ms

2 原因:
    一: 第一段循环:
        最外层的 i 的循环是100次。每个外层循环⼀次⾥⾯，都会发⽣1000次最内层 k 的循环的预测错误，
        所以⼀共会发⽣ 100 × 1000 = 10万次预测错误。
    二: 第二段循环:
        每100次循环，就会发⽣⼀次预测错误。这样的错误，在第⼆层j的循环发⽣的次数，还是1000次。
        最外层 i 的循环是10000次，所以⼀共会发⽣ 1000 × 10000 = 1000万次预测错误
    三: 第⼀段代码运⾏的时间要少得多了。因为第⼀段代码发⽣“分⽀预测”错误的情况⽐较少，
        更多的计算机指令，在流⽔线⾥顺序运⾏下去了，⽽不需要把运⾏到⼀半的指令丢弃掉，再去重新加载新的指令执⾏



