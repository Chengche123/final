1 互斥访问:
    一: 
        线程间可以通过共享变量来通告各自的状态，但是**访问共享变量过程本身也存在时序问题和冲突问题**。所以，这个任务必须依靠硬件的辅助来完成。
    二: 总线仲裁器
        总线是有仲裁器的，任何一个核心想操作总线上的任何信号(包括Lock信号)之前，都必须先获得仲裁。仲裁器的原理前文中已经描述过。正是这个**仲裁器充当了最原始最底层的绝对的串行化控制点**，保证即便是有多个核心同时试图争抢Lock信号，也只有一个核心抢到总线控制权，从而抢到Lock信号。Lock信号再去保证只有一个核心发起访存操作，从而保障对共享变量的串行访问。
    三: 粒度
        早期的CPU的确是锁定整个总线的，后来逐步优化，新的商用CPU几乎都增加了一些细粒度控制访问的硬件模块，可以**记录精细的需要锁定的起始内存地址+长度范围**，只有落入这些地址的访存请求，才会被检查是否有权限访问，这样性能就不会降低太多了。一旦某段地址被加锁，谁加的锁谁才被允许写入该区域(**通过访存请求中的核心标识符来区分**)，其他核心针对该地址段的加锁请求或者不带锁的写请求都会被阻塞，暂时不发送到总线，一直到总线被解锁之后。
    四: 共享变量(volatile)
        该不该用**Lock信号**，是需要**由程序控制**的，**访问共享变量时就要用**，访问非共享变量就不用。
        共享变量是需要被所有核心都看得到的，所以编译器不能像非共享变量一样直接把对应的数值放到某寄存器中来计算、更新，每次更新时，**必须用Stor指令存储到外部存储器中**，这样**其他核心才看得到**。具体的，编译器不会自动去检查某个变量是不是共享变量，而是要让程序员通过一些编译制导关键字来告诉编译器应该怎么做，比如volatileint a=0，其中**volatile关键字就是用来告知编译器不要把变量a存储到寄存器中，而是要写到外部存储器**。如果程序员忘记加制导关键字，程序会产生潜在bug。同理，对于volatile关 键字的变量，每次访问也必须从内存地址而不是寄存器中访问，这样才能保证访问到其他核心已经改动过(而后被存储到内存地址中)的值。

2 访存屏障:
    一: 为什么要访存屏障: **多核心间cache的同步需要一定的时间**
        加锁的原子操作只能保证多核心之间不会同时更改某个变量，但是**保证不了共享变量的最新值还没同步到对方缓存之前，锁变量却先被同步过去了**，而对方拿到锁后，共享变量依然没同步过来，结果**对方读到了旧数据**。
    二: 访存屏障
        能**让某个核心一执行它就停下等待直到子弹飞到目的地**的指令，叫做访存屏障( memory barrier,或者简称barrier)指令。
        Intel x86平台CPU给出了如下几种访存屏障指令，实际中可择机使用:
            Mfence: Memory Fence，不管是读还是写，位于Mfence指令**之前的所有访存指令**的执行结果一定全部同步完毕之后，才会执行Mfence**后面的访存指令**。
            Lfence: Load Fence，位于Lfence指令**之前的全部Load指令**都同步之后，再执行Lfence**后面的访存指令**。
            Sfence: Stor Fence， 位于Sfence指令**之前的全部Stor指令**都同步之后，再执行Sfence**后面的访存指令**。
    三: 












