1 三种方式可以避免数据竞争:
    一: (框架)避免从多个goroutine访问变量 monitor（监控）goroutine
    二: (框架)互斥
    三: 不要去写变量

2 (框架-内存模型的用处)为什么需要定义Happens Before关系来保证内存操作的可见性呢?
    一: 操作重排序
    二: CPU 多核心间独立Cache Line的同步问题

2 (框架-操作重排序):
    因为缺少显式的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，
    以任意方式，只要保证每一个goroutine自己的执行顺序一致

3 (框架-CPU 多核心间独立Cache Line的同步问题):
    一: 不同的cache和主存空间中可能存放着同一个数据的多个副本
    二: 实例:
            考虑一下下面代码片段的可能输出：
            var x, y int
            go func() {
                x = 1 // A1
                fmt.Print("y:", y, " ") // A2
            }()
            go func() {
                y = 1                   // B1
                fmt.Print("x:", x, " ") // B2
            }()
            实际运行时还是有些情况让我们有点惊讶：
            x:0 y:0
            y:0 x:0
    三: 像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，
        这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到

4 sync.Once惰性初始化:
    Go1.9中会先判断boolean变量是否为1(true)，只有不为1才锁定mutex，不再需要每次都锁定mutex