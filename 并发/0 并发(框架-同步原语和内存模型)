////////////////////////////////////  同步原语 ///////////////////////////////////
1 (框架-同步原语的用处):
    一: 保护临界资源(互斥量和条件变量)
    二: 任务编排(WaitGroup Channel)
    三: 消息传递(Channel)


2 (框架-同步结构体复制问题):
    一: 对结构体值的复制不但会生成该值的副本，还会生成其中字段的副本。如此一来，本应施加于此的并发安全保护也就失效了
    二: 对于sync包中的Mutex 、RWMutex 和Cond 类型，go vet 命令同样会检查此类复制问题，其原因也是相似的。
        一个比较彻底的解决方案是，避免直接使用它们，而使用它们的指针值。

////////////////////////////////////  内存模型 ///////////////////////////////////
1 (框架-内存模型的用处)为什么需要定义Happens Before关系来保证内存操作的可见性呢?
    一: 操作重排序
    二: CPU 多核心间独立Cache Line的同步问题

2 (框架-操作重排序):
    因为缺少显式的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，
    以任意方式，只要保证每一个goroutine自己的执行顺序一致

3 (框架-CPU 多核心间独立Cache Line的同步问题):
    一: 不同的cache和主存空间中可能存放着同一个数据的多个副本
    二: 实例:
            考虑一下下面代码片段的可能输出：
            var x, y int
            go func() {
                x = 1 // A1
                fmt.Print("y:", y, " ") // A2
            }()
            go func() {
                y = 1                   // B1
                fmt.Print("x:", x, " ") // B2
            }()
            实际运行时还是有些情况让我们有点惊讶：
            x:0 y:0
            y:0 x:0

.1 sync.Once惰性初始化:
    Go1.9中会先判断boolean变量是否为1(true)，只有不为1才锁定mutex，不再需要每次都锁定mutex