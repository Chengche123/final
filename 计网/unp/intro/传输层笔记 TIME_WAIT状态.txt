1 持续时间:
这个状态的持续时间是最长分节生命期（maximum segment lifetime，MSL）的两倍，有时候称之为2MSL。

每个数据报含有一个称为跳限（hop limit）的8位字段（见图A-1中IPv4的TTL字段和图A-2中IPv6的跳限字段），它的最大值为255。
MSL是任何IP数据报能够在因特网中存活的最长时间。假设：具有最大跳限（255）的分组在网络中存在的时间不可能超过MSL秒。

任何TCP实现都必须为MSL选择一个值。RFC 1122［Braden 1989］的建议值是2分钟，不过源自Berkeley的实现传统上改用30秒这个值。
这意味着TIME_WAIT状态的持续时间在1分钟到4分钟之间。

2 理由1:可靠地实现TCP全双工连接的终止；(重点)
第一个理由可以通过查看图2-5并假设最终的ACK丢失了来解释。
服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。
要是客户不维护状态信息，它将响应以一个RST（另外一种类型的TCP分节），该分节将被服务器解释成一个错误。
如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），
那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。
本例子也说明了为什么执行主动关闭的那一端是处于TIME_WAIT状态的那一端：因为可能不得不重传最终那个ACK的就是那一端。

3 理由2:允许老的重复分节在网络中消逝。
为理解存在TIME_WAIT状态的第二个理由，我们假设在12.106.32.254的1500端口和206.168.112.219的21端口之间有一个TCP连接。
我们关闭这个连接，过一段时间后在相同的IP地址和端口之间建立另一个连接。
后一个连接称为前一个连接的化身（incarnation），因为它们的IP地址和端口号都相同。
TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解成属于同一连接的某个新的化身。
为做到这一点，TCP将不给处于TIME_WAIT状态的连接发起新的化身。
既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。
通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。