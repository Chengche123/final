1 用户态相关:
    一: 无论是共享内存还是信号量，创建与初始化都遵循同样流程，通过ftok得到key，通过xxxget创建对象并生成id；
    二: 生产者和消费者都通过shmat将共享内存映射到各自的内存空间，在不同的进程里面映射的位置不同；
    三: 为了访问共享内存，需要信号量进行保护，信号量需要通过semctl初始化为某个值；
    四: 接下来生产者和消费者要通过semop(-1)来竞争信号量，如果生产者抢到信号量则写入，然后通过semop(+1)释放信号量，
        如果消费者抢到信号量则读出，然后通过semop(+1)释放信号量；
    五: 共享内存使用完毕，可以通过shmdt来解除映射。

2 共享内存的创建过程:
    一: 共享内存需要和文件进行关联。
        虚拟地址空间可以和物理内存关联，但是物理内存是某个进程独享的
        虚拟地址空间也可以映射到一个文件，文件是可以跨进程共享的。
    二: 共享内存映射到一个内存文件系统上的文件,叫做shmem_fs_type
        shmem_fs_type文件系统上的文件指向独特的shmem_file_operations

3 如何将共享内存映射到虚拟地址空间？
    一: 通过共享内存的id找到shmem上的内存文件
    二: 创建一个新的struct file，原因:
        1) shmem中shm_file用于管理内存文件，是一个中立的，独立于任何一个进程的角色
        2) 而新创建的struct file是专门用于做内存映射的
           一个硬盘上的文件要映射到虚拟地址空间中的时候，需要在vm_area_struct里面有一个struct file *vm_file指向硬盘上的文件，
           现在变成内存文件了
        3) 新创建的struct file的file_operations也发生了变化，变成了shm_file_operations。
    三: 虽然基于内存的文件系统，已经为这个内存文件分配了inode，但是内存也却是一点儿都没分配，只有在发生缺页异常的时候才进行分配。
    四: 共享内存映射到了虚拟地址空间后，进程可以像访问本地内存一样访问共享内存。

